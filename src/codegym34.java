// 类型转换
// 变量无法更改其类型，但有个位置可让你转换类型。这个位置就是赋值操作。
// 我们可以指出两种类型的转换：拓宽原始转换和窄化原始转换。拓宽就像将小篮子里的东西放到大篮子一样。这个过程是悄无声息地轻松完成。窄化就好比将大篮子里的东西放入小篮子。这样一来，空间就不足，你可能要扔掉一些东西。
// 以下是根据‘篮子’大小排序的类型：
/*
byte 1
short 2         char 2
int 4
long 8

float 4
double 8
 */

// 不过注意几点：
/*
1. 尽管 char 的大小与 short 一样，但你也无法自由地在两者间移动值。值从 short 移动到 char 时，小于 0 的值总是丢失。值从 char 移动到 short 时，大于 32,000 的值会丢失。

2.整数转换成小数时，该数字最不重要的小数位会被丢弃。不过，这也是可接受的，因为分数的目的是存储近似值。
 */

// 执行窄化转换时，我们必须明确指令计算机我们没有发生错误：我们是故意舍弃部分数字。我们使用强制转换运算符（即括号中的类型名称）执行此操作。

// 按照如下方式赋值不同的类型变量：
/* 1
代码：
byte a = 115;
int b = a;
说明：
拓宽原始转换。一切顺利。
 */

/* 2
代码：
int c = 10000;
byte d = (byte) c;
说明：
窄化原始转换。我们必须明确指出应该丢弃多余的字节。
 */

/* 3
代码：
int c = 10;
byte d = (byte) c;
说明：
窄化原始转换。我们必须明确指出丢弃多余的字节，即使它们等于 0。
 */

/* 4
代码：
float f = 10000;
long l = (long) (f * f);
float f2 = l;
long l2 = (long) f2;
说明：
赋值给 float 类型时，将拓宽原始转换。赋值给 long 类型时，将窄化原始转换。需要强制转换运算符。
 */

/* 5
代码：
double d = 1;
float f = (float) d;
long l = (long) f;
int i = (int) l;
short s = (short) i;
byte b = (byte) s;
说明：
所有赋值操作均进行窄化转换，除了第一行。这些转换要求我们明确指示类型转换。
 */

// 强制转换运算符必须在该数字的数字/变量被丢弃之前或窄化原始转化发生时放置。强制转换运算符仅影响紧随其后的数字/变量。
/*
代码：
float f = 10000;
long l = (long) f * f;
说明：
两个变量中只有一个强制转换为 long: long 与 float 的乘积等于 float。

代码：
float f = 10000;
long l = (long) (f * f);
说明：
整个表达式被强制转换为 long 整数。
 */